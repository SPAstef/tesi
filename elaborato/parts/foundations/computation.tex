\chapter{Computational Background}
A \emph{computational model} (or model of computation) is any kind of system able to describe 
how to produce some \emph{output} given some \emph{input}~\cite{Savage1997}.
Different models do this in different ways, each one with its own strength and weaknesses in terms
of \emph{expressivness}, \emph{complexity} and \emph{succintness}.
Two historically important models of computations are Alonzo Church's 
\emph{\(\lambda \)-calculus}~\cite{Church1941} and Alan Turing's 
\emph{Turing machine} (TM)~\cite{Turing1950}. 
Among several equivalent models~\cite{Davis2004}, Turing machines became the standard model of 
computation.
\begin{definition}[Turing machine~\cite{Papadimitriou1994}]\label{def:turing_machine}
  A Turing machine is a quadruple \(\mathcal{M} = \Tuple{\Sigma, Q, q_0, \delta}\), where 
  the \emph{alphabet} \(\Sigma \) is a set of symbols such that \(\sqcup \in \Sigma \), the 
  \emph{state set} \(Q\) is a set of symbols such that \(\Set{\bot, \top} \subseteq Q\), 
  \(q_0 \in Q\) is the \emph{initial state}, and 
  \(\delta\colon {\Parens*{Q \setminus \Set{\bot, \top}} \times \Sigma} \to 
  {Q \times \Sigma \times \Set{\leftarrow, \rightarrow}}\) is the \emph{transition function}.
\end{definition}

By only requiring \(\delta \) to be a relation instead of a function, we obtain the so-called 
\emph{non-deterministic} Turing machine (NTM): given a state and an alphabet symbol, the machine 
can take different choiches at every step.
A TM \(\mathcal{M}\) manipulates a string \(\overbar{\sigma}\) over the alphabet 
\(\Sigma \setminus \Set{\sqcup}\) by placing it over an \emph{infinite, discrete working tape} 
\(\Tapework \), a total order isomorphic to \(\mathbb{Z}\).
The input string is positioned such that its first symbol is matched with the position \(0\) 
of the tape; all the positions before the first symbol and after the last symbol are filled 
with the \emph{blank} symbol \(\sqcup \).
The computation \(\call{\mathcal{M}}{\overbar{\sigma}}\) starts in the initial state \(q_0\) with 
the \emph{head} of the TM positioned over the position \(0\) of the tape, and proceeds according to 
the transition function: depending on the current state \(q\) and the symbol \(\sigma \) written in 
the current location of the head, it replaces \(\sigma \) with a new symbol \(\sigma'\), it moves 
the head to the left (\(\leftarrow \)) or to the right (\(\rightarrow \)) and it transitions into a 
new state \(q'\).
The computation \emph{terminates} whenever one of the two \emph{halting} states is reached: if
\(\call{\mathcal{M}}{\overbar{\sigma}} = \bot \), then the input string \(\overbar{\sigma}\) is 
\emph{rejected}, else if \(\call{\mathcal{M}}{\overbar{\sigma}} = \top \), then \(\overbar{\sigma}\) 
is \emph{accepted}.
It can also happen that the computation does not terminate: in such cases, we write 
\(\call{\mathcal{M}}{\overbar{\sigma}} = {\uparrow}\) and we say that the computation \emph{hangs}.

\input{parts/foundations/computation/interactive.tex}
\input{parts/foundations/computation/complexity.tex}
\input{parts/foundations/computation/games.tex}
\input{parts/foundations/computation/zkp.tex}
